---
layout: single
title: "SEB Section 1 Closure"
categories: [JS/Node]
tag: [codestates, JS/Node]
toc: true
---

# closure 란?

- 클로저(closure)는 함수와 그 함수가 선언됐을 때의 렉시컬 환경과의 조합이다.
- 의미가 난해해서 예를 들어 익혀보자.

```js
function outerFunc() {
  var x = 10;
  var innerFunc = function () {
    console.log(x);
  };
  innerFunc();
}

outerFunc(); // 10
```

- 함수 outerFunc 내에서 내부함수 innderFunc가 선언되고 호출되었다. 이때 내부함수 innerFunc는 자신을 포함하고 있는 외부함수 outerFunc의 변수 x에 접근할 수 있다. 이는 함수 innerFunc가 함수 outerFucn의 내부에서 선언되었기 때문이다.
- 동작 원리를 보자면,
  1. innerFunc 함수 스코프(함수 자신의 스코프를 가리키는 활성 객체)내에서 변수 x를 검색한다. 검색이 실패하였다.
  2. innerFunc 함수를 포함하는 외부 함수 outerFunc의 스코프(함수 outerFunc의 스코프를 가리키는 함수 outerFunc의 활성 객체)에서 변수 x를 검색한다. 검색이 성공하였다.

```js
function outerFunc() {
  var x = 10;
  var innerFunc = function () {
    console.log(x);
  };
  return innerFunc;
}

/**
 *  함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다.
 *  그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다.
 */
var inner = outerFunc();
inner(); // 10
```

- 함수 outerFunc는 내부함수 innerFunc를 반환하고 생을 마감했다. 즉, 함수 outerFunc는 실행된 이후 콜스택에서 제거되었으므로 함수 outerFunc의 변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다.
- 하지만 실행 결과는 10이다. 함수 outerFunc의 지역변수 x가 다시 부활이라도 한 듯이 동작하고 있다.
- 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데, 이러한 함수를 클로저 라고 부른다.

- **클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근 할 수 있는 함수**를 말한다.
- 간략하게 말하면 **클로저는 자신이 생성될 때의 환경을 기억하는 함수**이다.
